# Chekpoints
Установили VirtualBox на свой комьютер. Создали две виртуальные машины: `bet` — это основной хост. а `remote` — это удаленный хост:

<img width="945" height="637" alt="image" src="https://github.com/user-attachments/assets/5b25d5e4-dd12-472c-988a-271587d9bc23" />

Настроим сеть для этих двух VM так, чтобы у них в поле сетевого подключения было выбрано **Сетевой мост (Bridge Adapter)**. Это позволит нашим VM получить `IP`-адреса из той же сети, что и наш основной компьютер, как если бы это были два отдельных физических компьюетра в нашей домашней сети:

<img width="1113" height="620" alt="image" src="https://github.com/user-attachments/assets/bd1fa267-02a6-457d-83c1-98167fa00c5c" />
<img width="1118" height="622" alt="image" src="https://github.com/user-attachments/assets/10a05eef-5fa6-48db-8a82-3234e6a3c824" />

Запусти наши VM и проверим, имеют ли они доступ к друг другу c помощью команды `ping IP_ADDR`.  Для этого узнаем `IP`-адреса наших VM с помощью команды `ip a', где объект `a` показывает все сетевые адреса:

<img width="725" height="469" alt="image" src="https://github.com/user-attachments/assets/6dff89c9-6a96-4494-a6af-cf75bdf11026" />
<img width="721" height="460" alt="image" src="https://github.com/user-attachments/assets/43c9e03a-2179-4fa2-b74f-ebc186937ec5" />

Отсюда видим название сетевых интерфейсов `eth0` и их `IP`-адреса.

**Утилита IP**: позволяет посмотреть сетевые интерфейсы и `IP`-адреса им присвоенные, посмотреть и настроить таблицу маршрутизации, включать и отключать сетевые интерфейсы. управлять маршутризацией.

```bash
# ip [опции] объект команда [параметры]
опции — это глобальные настройки, которые сказываются на работе всей утилиты.
объект — это тип данных, с которым надо будет работать. Например: адреса, устройства, таблица arp, таблица маршрутизации.
команды — какие-либо действия с объектом
параметры — командам иногда нужно передавать параметры
```

**Приведём парочку опций**:

```bash
-v, -Version — вывод информации об утилите и её версии
-h, -human — выводить данные в удобном для человека виде
-s, -stats — включает вывод статистической информации
-d, -details — показывает ещё больше подробностей
-f, -family — позволяет указать протокол, с которым нужно будет работать. Опция должна принимать одной из значений: bridge, dnet, inet, inet6, ipx, link. По умолчанию используется inet,link, которые говорят об отсутствии протокола
-r, -resolve — определять имена хостов с помощью DNS
```

**Самые важные объекты:**

```bash
address/a — сетевые адреса
link/l — физическое сетевое устроство
neighbour/neigh — просмотр и управления ARP
route/r — управление маршрутизацией
rule/ru — правила маршрутизации
tunnel/t — настройка туннелирования
```

**Команды**

```bash
add, change, del  или delete, flush, get, list или show, monitor, replace, save, get, update.
Если не задана команда, то по умолчанию show.
```

**Утилита ping**: используется для диагностики сети. Она позволяет проверить, доступен ли удаленный хост или нет. Для этого утилита проверяет, может ли хост отвечать на сетевые запросы с помощью протокола `ICMP`.
Она передает небольшой пакет с данными `ICMP` и ожидает получить обратно пакет ответа, если получает, то считает, что удаленный узел доступен. 
`ICMP` — это надстройка над протоколом `IP`, которая используется для передачи служебных сообщений и сообщений об ошибках.

**Что делает команда ping?**
Когда мы отправляем запрос `ping` удаленному узлу, утилита устанавливает для каждого пакета уникальный индентификатор, а также `TTL` и время отправки пакета.
Если хост доступен, он отправляет ответ, на основе времени отправки утилита может вычислить время прохождения пакета туда и обратно.
Затем отправляет следующий пакет. В конце рассчитывается общее количество отправленных и принятых пакетов, процент потерь и другие данные.

```bash
# ping оции адрес_узла
Парочку опций
-4 — использовать только ipv4
-6 — использовать только ipv6
-b — разрешить ping широковещательного адреса
-с — количество пакетов, которые нужно отправить
-f — режим флуда, в этом режиме пакеты передаются без задержке
-i — интервал в секундах между отправкой пакетов
-n — не получать домены ip адресов
-s — размер одного пакета
-t — установить TTL вручную
-v — более подробный вывод
```
На основном хосте выполним команду `ping google.com` и запишем результат в файл `ping google.com > result_of_ping.txt`:

<img width="752" height="252" alt="image" src="https://github.com/user-attachments/assets/35a513e7-bf70-4cce-8a79-c486335f19b6" />

Давайте отследим маршрут до `google.com`. Для этого используем утилиту `traceroute google.com` и запишем результат в файл `traceroute google.com > traceroute_result.txt && cat taceroute_result.txt`:

<img width="750" height="281" alt="image" src="https://github.com/user-attachments/assets/f8086787-4235-42cb-8f8c-db560cdd880a" />

**Разбор вывода команды traceroute**:

- 1-ый столбец — номер прыжка.
- 2-ой столбец — указывает `IP`-адрес или имя хоста устройства на определённом переходе.
- 3-й, 4-й, 5-й столбцы — это `RTT` или время приёма-передачи. Благодаря ему можно узнать, сколько времени потребовалось каждому пакету, чтобы достичь определённого `IP`-адреса и вернуться обратно.
- звездочка — если данный маршрутизатор не отвечает на запросы
  
**Утилита traceroute**: данная команда использует `UDP` пакеты. Она отправляет пакет с `TTL=1` и смотрит адрес ответившего узла, дальше `TTL=2`, `TTL=3` и так пока не достигнет цели. 
Каждый раз отправляется по три пакета и для каждого из них измеряется время прохождения. Пакет отправляется на случайный порт, который, скорее всего, не занят.
Когда утилита получает сообщение от целевого узла о том, что порт недоступен, трассировка считается завершенной.

```bash
# traceroute опции адрес_узла
-4/-6 — использовать ipv4/ipv6 протоколы
-I — использовать ICMP пакеты вместо UDP
-T — использовать TCP пакеты вместо UDP
-F — не фрагментировать пакеты
-f — указать TTL, с которого нужно начать
-g — передать пакет через указанный шлюз
-i — передать пакет через указанный интерфейс
-m — максимальное количество узлов, через который пройдет пакет
-q — количество пакетов, которое отправляется за раз (по умолчанию 3)
-n — не узнавать доменные имена
-p — указать порт вместо порта по умолчанию
-w — установить время ожидания ответа от узла. По умолчанию полсекунды
-r — использовать другой роутер вместо того, что указан в таблице маршрутизации
-z — минимальный интервал между пакетами
-mtu — указать размер пакета
-U — использовать UDP
```
Давайте познакомимся с файрволом. 

**Что такое файрвол?** — это межсетевые экраны, а это центральный элемент архитектуры любой сети. Они разработаны таким образом, чтобы не пропускать весь сетевой трафик, кроме разрешенного нами. Они обычно работают на 4-м уровне, контролируя доступ `TCP` и `UDP`.

Проверим статус файрвола на удалённом хосте с помощью команды `sudo ufw status`:

<img width="608" height="73" alt="image" src="https://github.com/user-attachments/assets/67bfda11-0d84-43ba-a8ea-a3100e023291" />

**Важно**:По умолчанию в Linux установлено две утилиты для управления межсетевым экраном на хосте. Это Iptableas и ufw. 
 
`iptables` — это утилита для настройки встроенного межсетевого экрана в Linux на уровне ядра, работает на основе таблиц и цепочек (chains). Основной недостаток `iptables`: сложность в использовании, именно поэтому был разработан `ufw`. 
 
`UFW` (Uncomplicated Firewall) — это упрощенный интерфейс для управления `iptables`, созданный для пользователей Ubuntu и других дистрибутивов Linux. В данной таске ты будешь работать именно с `ufw`.

```bash
# ufw опции действие параметры

Пара опций

- --version — вывести версию брандаумера
- --dry-run — тестовый запуск, никакие реальные действия не выполняются

Пара команд

enable — включить фаервол и добавить его в автозагрузку
disable — отключить фаервол и удалить его из автозагрузки
reload — перезагрузить фаервол
default — задать политику по умолчанию. Доступно allow, deny, reject, а также три вида трафика — incoming, outgoing, routed
logging — включить журналирование или изменить уровень подробности
reset — сбросить все настройки до состония по умолчанию
status — посмотреть статус фаервола
show — посмотреть один из отчетов по работе
allow — добавить разрешающее правило
deny — добавить запрещающее правило
reject — добавить отбрасывающее правило
limit — добавить лимитирующее правило
delete — удалить правило
insert — вставить правило
```

Установим **Wireshark** и начнем захват трафика на нашем сетевом интерфейсе `eth0` на основном хосте:

```bash
sudo apt update
sudo apt install wireshark
wireshark --version
```
Покажем в терминале:

<img width="744" height="409" alt="image" src="https://github.com/user-attachments/assets/07cc3071-07b7-449c-9121-e73d20fca957" />

**Важно**: Wireshark — это мощный сетевой анализатор, который может использоваться для анализа трафика, проходящего через сетевой интерфейс вашего компьютера. Он может понадобиться для обнаружения и решения проблем с сетью, отладки ваших веб-приложений, сетевых программ или сайтов. Wireshark позволяет полностью просматривать содержимое пакета на всех уровнях: так вы сможете лучше понять как работает сеть на низком уровне.

На удалённом хосте установим `telnet`.

```bash
sudo apt update
sudo apt install telnetd
```

**Важно**: Telnet — это сетевая утилита, которая позволяет соединиться с удаленным портом любого компьютера и установить интерактивный канал связи, например, для передачи команд или получения информации. Эта утилита очень часто использовалась раньше, для удаленного управления компьютером с Linux, но потом ей на замену пришел защищенный протокол SSH. Но telnet все еще используется, например, для тестирования сети, проверки портов, а также для взаимодействия с различными IoT устройствами и роутерами.

```bash
# telnet опции хост порт

Хост — это домен удаленного компьютера, к которому следует подключиться. А порт — порт на этом комьютере.

Основные опции:
-4 — использовать ipv4
-6 — использовать ipv6
-a — автоматический ход, берём имя пользователя из переменной окружения USER
-b — использовать локальный сокет
-d — включить режим откладке
-E — отключить поддержку Escape последовательностей

Может работать в двух режимах:

1) Построчный — здесь строка редактируется на локальном компьютере и отправляется тогда, когда она будет полностью готова.

2) Посимвольный — все набираемые символы отправляются на удаленный сервер
```

Покажем в терминале:

<img width="749" height="326" alt="image" src="https://github.com/user-attachments/assets/6d1968b4-f4cf-4ec4-8bf5-60d24854cd87" />

Подключимся с основного хоста к удаленному `telnet IP_addr_remote_host` и выполним команду `uname -a`, предварительно начав захват трафика сетевого интерфейса `eth0`:

<img width="718" height="414" alt="image" src="https://github.com/user-attachments/assets/86ce62ed-be18-42d2-9d66-aad4a022221d" />

Выполним команду `uname -a`:

<img width="719" height="74" alt="image" src="https://github.com/user-attachments/assets/0e70a104-8e5d-44a8-b089-b6198de195b2" />
<img width="796" height="690" alt="image" src="https://github.com/user-attachments/assets/8ae06c0c-ddb2-4c38-8dbf-07fae6980b09" />

Как мы видим, пакеты незашифрованы. Удалим `Telnet`-сервер с удаленного хоста с помощью команды `sudo apt purge telnetd`.

Выполним те же шаги, что и выше, только подключимся к удаленному хосту по `SSH`:

<img width="729" height="242" alt="image" src="https://github.com/user-attachments/assets/104fded5-9327-4d7f-a206-490afb941044" />

Выполним команду `uname -a`, предварительно захватив трафик `eth0`:

<img width="729" height="77" alt="image" src="https://github.com/user-attachments/assets/fec677ff-3559-4245-8ee3-e4cf42d9db5f" />
<img width="792" height="645" alt="image" src="https://github.com/user-attachments/assets/942e098a-570f-4b07-9914-95c9914fd183" />

Как видим, данные зашифрованы.









