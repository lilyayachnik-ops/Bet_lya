# Chekpoints
Установили VirtualBox на свой комьютер. Создали две виртуальные машины: `bet` — это основной хост. а `remote` — это удаленный хост:

<img width="945" height="637" alt="image" src="https://github.com/user-attachments/assets/5b25d5e4-dd12-472c-988a-271587d9bc23" />

Настроим сеть для этих двух VM так, чтобы у них в поле сетевого подключения было выбрано **Сетевой мост (Bridge Adapter)**. Это позволит нашим VM получить `IP`-адреса из той же сети, что и наш основной компьютер, как если бы это были два отдельных физических компьюетра в нашей домашней сети:

<img width="1113" height="620" alt="image" src="https://github.com/user-attachments/assets/bd1fa267-02a6-457d-83c1-98167fa00c5c" />
<img width="1118" height="622" alt="image" src="https://github.com/user-attachments/assets/10a05eef-5fa6-48db-8a82-3234e6a3c824" />

Запусти наши VM и проверим, имеют ли они доступ к друг другу c помощью команды `ping IP_ADDR`.  Для этого узнаем `IP`-адреса наших VM с помощью команды `ip a', где объект `a` показывает все сетевые адреса:

<img width="725" height="469" alt="image" src="https://github.com/user-attachments/assets/6dff89c9-6a96-4494-a6af-cf75bdf11026" />
<img width="721" height="460" alt="image" src="https://github.com/user-attachments/assets/43c9e03a-2179-4fa2-b74f-ebc186937ec5" />

Отсюда видим название сетевых интерфейсов `eth0` и их `IP`-адреса.

**Утилита IP**: позволяет посмотреть сетевые интерфейсы и `IP`-адреса им присвоенные, посмотреть и настроить таблицу маршрутизации, включать и отключать сетевые интерфейсы. управлять маршутризацией.

```bash
# ip [опции] объект команда [параметры]
опции — это глобальные настройки, которые сказываются на работе всей утилиты.
объект — это тип данных, с которым надо будет работать. Например: адреса, устройства, таблица arp, таблица маршрутизации.
команды — какие-либо действия с объектом
параметры — командам иногда нужно передавать параметры
```

**Приведём парочку опций**:

```bash
-v, -Version — вывод информации об утилите и её версии
-h, -human — выводить данные в удобном для человека виде
-s, -stats — включает вывод статистической информации
-d, -details — показывает ещё больше подробностей
-f, -family — позволяет указать протокол, с которым нужно будет работать. Опция должна принимать одной из значений: bridge, dnet, inet, inet6, ipx, link. По умолчанию используется inet,link, которые говорят об отсутствии протокола
-r, -resolve — определять имена хостов с помощью DNS
```

**Самые важные объекты:**

```bash
address/a — сетевые адреса
link/l — физическое сетевое устроство
neighbour/neigh — просмотр и управления ARP
route/r — управление маршрутизацией
rule/ru — правила маршрутизации
tunnel/t — настройка туннелирования
```

**Команды**

```bash
add, change, del  или delete, flush, get, list или show, monitor, replace, save, get, update.
Если не задана команда, то по умолчанию show.
```

**Утилита ping**: используется для диагностики сети. Она позволяет проверить, доступен ли удаленный хост или нет. Для этого утилита проверяет, может ли хост отвечать на сетевые запросы с помощью протокола `ICMP`.
Она передает небольшой пакет с данными `ICMP` и ожидает получить обратно пакет ответа, если получает, то считает, что удаленный узел доступен. 
`ICMP` — это надстройка над протоколом `IP`, которая используется для передачи служебных сообщений и сообщений об ошибках.

**Что делает команда ping?**
Когда мы отправляем запрос `ping` удаленному узлу, утилита устанавливает для каждого пакета уникальный индентификатор, а также `TTL` и время отправки пакета.
Если хост доступен, он отправляет ответ, на основе времени отправки утилита может вычислить время прохождения пакета туда и обратно.
Затем отправляет следующий пакет. В конце рассчитывается общее количество отправленных и принятых пакетов, процент потерь и другие данные.

```bash
# ping оции адрес_узла
Парочку опций
-4 — использовать только ipv4
-6 — использовать только ipv6
-b — разрешить ping широковещательного адреса
-с — количество пакетов, которые нужно отправить
-f — режим флуда, в этом режиме пакеты передаются без задержке
-i — интервал в секундах между отправкой пакетов
-n — не получать домены ip адресов
-s — размер одного пакета
-t — установить TTL вручную
-v — более подробный вывод
```
На основном хосте выполним команду `ping google.com` и запишем результат в файл `ping google.com > result_of_ping.txt`:

<img width="752" height="252" alt="image" src="https://github.com/user-attachments/assets/35a513e7-bf70-4cce-8a79-c486335f19b6" />

Давайте отследим маршрут до `google.com`. Для этого используем утилиту `traceroute google.com` и запишем результат в файл `traceroute google.com > traceroute_result.txt && cat taceroute_result.txt`:

<img width="750" height="281" alt="image" src="https://github.com/user-attachments/assets/f8086787-4235-42cb-8f8c-db560cdd880a" />

**Разбор вывода команды traceroute**:

- 1-ый столбец — номер прыжка.
- 2-ой столбец — указывает `IP`-адрес или имя хоста устройства на определённом переходе.
- 3-й, 4-й, 5-й столбцы — это `RTT` или время приёма-передачи. Благодаря ему можно узнать, сколько времени потребовалось каждому пакету, чтобы достичь определённого `IP`-адреса и вернуться обратно.
- звездочка — если данный маршрутизатор не отвечает на запросы
  
**Утилита traceroute**: данная команда использует `UDP` пакеты. Она отправляет пакет с `TTL=1` и смотрит адрес ответившего узла, дальше `TTL=2`, `TTL=3` и так пока не достигнет цели. 
Каждый раз отправляется по три пакета и для каждого из них измеряется время прохождения. Пакет отправляется на случайный порт, который, скорее всего, не занят.
Когда утилита получает сообщение от целевого узла о том, что порт недоступен, трассировка считается завершенной.

```bash
# traceroute опции адрес_узла
-4/-6 — использовать ipv4/ipv6 протоколы
-I — использовать ICMP пакеты вместо UDP
-T — использовать TCP пакеты вместо UDP
-F — не фрагментировать пакеты
-f — указать TTL, с которого нужно начать
-g — передать пакет через указанный шлюз
-i — передать пакет через указанный интерфейс
-m — максимальное количество узлов, через который пройдет пакет
-q — количество пакетов, которое отправляется за раз (по умолчанию 3)
-n — не узнавать доменные имена
-p — указать порт вместо порта по умолчанию
-w — установить время ожидания ответа от узла. По умолчанию полсекунды
-r — использовать другой роутер вместо того, что указан в таблице маршрутизации
-z — минимальный интервал между пакетами
-mtu — указать размер пакета
-U — использовать UDP
```
Давайте познакомимся с файрволом. 

**Что такое файрвол?** — это межсетевые экраны, а это центральный элемент архитектуры любой сети. Они разработаны таким образом, чтобы не пропускать весь сетевой трафик, кроме разрешенного нами. Они обычно работают на 4-м уровне, контролируя доступ `TCP` и `UDP`.
